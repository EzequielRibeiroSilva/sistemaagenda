# ============================================
# PostgreSQL Configuration Otimizado para Produção
# Painel de Agendamento Multi-Tenant
# ============================================
# 
# Este arquivo é otimizado para:
# - Servidor com 4GB RAM / 2 CPUs (ajustar conforme servidor)
# - Workload OLTP (muitas transações pequenas)
# - Sistema multi-tenant com muitas conexões
#
# Para aplicar: Montar este arquivo no container PostgreSQL
# ============================================

# --------------------------------------------
# CONEXÕES
# --------------------------------------------
# Fórmula: (num_instances * pool_max) + admin_connections
# Exemplo: (3 instâncias * 25 pool) + 20 admin = 95
max_connections = 100
superuser_reserved_connections = 3

# --------------------------------------------
# MEMÓRIA (ajustar baseado no servidor)
# --------------------------------------------
# shared_buffers: 25% da RAM total
shared_buffers = 1GB

# effective_cache_size: 75% da RAM total (estimativa do cache do SO)
effective_cache_size = 3GB

# work_mem: Memória para sorts/joins por operação
# Cuidado: max_connections * work_mem pode usar muita RAM
work_mem = 16MB

# maintenance_work_mem: Para VACUUM, CREATE INDEX, etc.
maintenance_work_mem = 256MB

# huge_pages: Usar huge pages se disponível no SO
huge_pages = try

# --------------------------------------------
# WAL (Write-Ahead Log)
# --------------------------------------------
# wal_buffers: Memória para WAL (auto = ~3% shared_buffers)
wal_buffers = 32MB

# max_wal_size: Tamanho máximo antes de checkpoint
max_wal_size = 2GB

# min_wal_size: Tamanho mínimo reservado
min_wal_size = 512MB

# checkpoint_completion_target: Espalhar checkpoint ao longo do tempo
checkpoint_completion_target = 0.9

# checkpoint_timeout: Forçar checkpoint a cada X tempo
checkpoint_timeout = 10min

# --------------------------------------------
# PLANNER / QUERY OPTIMIZER
# --------------------------------------------
# random_page_cost: Menor para SSDs (1.1-1.5), maior para HDDs (4.0)
random_page_cost = 1.1

# effective_io_concurrency: Maior para SSDs
effective_io_concurrency = 200

# parallel_tuple_cost / parallel_setup_cost: Ajustes para paralelismo
max_parallel_workers_per_gather = 2
max_parallel_workers = 4
max_worker_processes = 8

# --------------------------------------------
# AUTOVACUUM
# --------------------------------------------
autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 30s
autovacuum_vacuum_threshold = 50
autovacuum_analyze_threshold = 50
autovacuum_vacuum_scale_factor = 0.1
autovacuum_analyze_scale_factor = 0.05
autovacuum_vacuum_cost_delay = 10ms
autovacuum_vacuum_cost_limit = 1000

# --------------------------------------------
# LOGGING
# --------------------------------------------
# Logar queries lentas (>1 segundo)
log_min_duration_statement = 1000

# O que logar
log_statement = 'ddl'
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on
log_temp_files = 0
log_autovacuum_min_duration = 1000

# Timezone
log_timezone = 'America/Sao_Paulo'
timezone = 'America/Sao_Paulo'

# --------------------------------------------
# LOCALE
# --------------------------------------------
lc_messages = 'en_US.utf8'
lc_monetary = 'pt_BR.utf8'
lc_numeric = 'pt_BR.utf8'
lc_time = 'pt_BR.utf8'
default_text_search_config = 'pg_catalog.portuguese'

# --------------------------------------------
# SEGURANÇA
# --------------------------------------------
# Statement timeout global (30 segundos)
statement_timeout = 30000

# Lock timeout (10 segundos)
lock_timeout = 10000

# Idle transaction timeout (5 minutos)
idle_in_transaction_session_timeout = 300000

# --------------------------------------------
# REPLICAÇÃO (para futuro)
# --------------------------------------------
# Ativar quando usar read replicas
# wal_level = replica
# max_wal_senders = 3
# max_replication_slots = 3

# --------------------------------------------
# EXTENSÕES NECESSÁRIAS
# --------------------------------------------
# Carregar btree_gist para constraint EXCLUDE
shared_preload_libraries = 'pg_stat_statements'

# pg_stat_statements para monitoramento de queries
pg_stat_statements.max = 10000
pg_stat_statements.track = all

